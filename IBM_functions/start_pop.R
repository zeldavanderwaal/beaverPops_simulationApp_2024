cat("startpop()  -  ")

############################ FUN: startpop_function - simulate init terrs   
 # pts = reactive: release points generated by user
 # habmap_raster = data: raster of hab suit map (may change/index by country when upscaling?)
 # demog= user input: demographics of released groups  
 # Nyoungs_perfam= user input: number of young per released groups   

startpop_function <-function(initValues, habmap_raster,depCells ) { 
  cat("\nfunction: startpop\n")  
         
        routes <- data.frame(bvr=0, cell=0)
        hab <- terra::unwrap(habmap_raster)
        
        rter <- terra::rast(hab)  # empty raster 
        
        values(hab)[is.na(values(hab))] <- 0
        matNrows <- nrow(rter)
        matNcols <- ncol(rter)
        values(rter)[is.na(values(rter))] <- 0
        ## create territories
        ter <- ter0 <- matrix (0, ncol=matNcols , nrow=matNrows, byrow=F) 
        rter[depCells] <- initValues$group     
         
          ## move pts to new locations here 
          num.fam <- nrow(initValues)
          families <-  data.frame(fam.id=initValues$group, num.m=initValues$mal, num.f=initValues$fem, young=initValues$young,   qual=0, stringsAsFactors=FALSE)
          start   <-  depCells# tay$index 
          
         # depCells <- c(9579, 11459, 19597)
         # rter[depCells] <- c(1,2,3)
          disp <- tidyr::uncount(data.frame(fam.id=families$fam.id,2), 2)$fam.id 
           if(length(disp)>0) {
               disp <- data.frame(fam.id=disp, ind.id=1:length(disp)) 
               for (id in psample(disp$fam.id)) { 
                    ter <- terra::wrap(rter)
                    hab <- terra::wrap(hab)
                    disp.fail <<- 0
                    disp_compute <- dispersal2(id, fam=families, ter=  ter , hab=hab  , famsize.max, move.max, hab.tot.quality=15, routes)  
                                     
                          families <- disp_compute [[1]]
                          ter <- terra::unwrap(disp_compute [[2]] )
                                 } 
                             }   
          table(values(terra::unwrap(disp_compute [[2]] )))
       
  startf <- adjacent.id(rter, cells=which(terra::values(rter)==id), id=id, directions=8)
  startf.natal <- startf
   
  start.here <- psample(find.best.hab(startf, hab ,origin=NA), 1)  ###
  # wander around
  path <- wander2(id, hab=hab, origin=start.here)  ### Added Mar 2020
 
  if(length(path)==0) path <- start.here           ### Added Mar 2020
  
  #now start looking around destination for territory. 
  start.here <- path[length(path)]
  startf <- adjacent.id(ter, cells=which(terra::values(ter)==id), id=id, directions=8)
  startf.natal <- startf
  
  
  
          
        adjacent(rter , depCells, directions=8 ) %>% ### initial - locate points within suit of disp
          data.frame() %>% 
          mutate(id=sapply(from,function(x) which(x == start)),
                 hab=as.matrix(hab, ncol=matNcols , nrow=matNrows, byrow=FALSE) [to]) %>% 
        #  filter(hab >0) %>% #sep20
          distinct(to, .keep_all=TRUE) ->
          start_df
        
        ## note the adjacent()function omits NA cells? if NA in map inds can jump over..
        ## sample one start point per family within disp or suit, and distinct
        sd1 <- start_df %>% group_by(id  ) %>% summarise(maxhab=max(hab, na.rm=TRUE))#cell= to[ hab==max(hab)])
        
        sd1 <- merge(sd1, start_df) 
        sd1 <- sd1[sd1$hab == sd1$maxhab,] 
        startcells <- sd1[!is.na(sd1$id),] %>% group_by(id ) %>% summarise(cell= unique(to)[sample(1:length(unique(to)),1)] )
          
         
        startid_suboptimal <- which(as.matrix(hab, ncol=matNcols , nrow=matNrows, byrow=FALSE) [startcells$cell]<2)
         
        
         ter[unique(start_df$from)] <- unique(start_df$id) # start from relocated point?
         
        
        ## store in families and ter
        families$qual <- sapply(families$fam.id,function(x, hab, ter) sum(hab[ter==x]), hab=as.matrix(hab, ncol=matNcols , nrow=matNrows, byrow=FALSE) , ter=ter)
        families$qual[families$qual==1] <- 0
         Ntries <- 0  
         
        cat("simulate starting territories for") 
        
          families <- families[order(families$fam.id),]
            grow <- families$fam.id[which(families$qual < hab.tot.quality) ] ## id ## , pairs=FALSE = no col from/to
        if(length(grow)>0) {  
                 ids <-  sample(grow,length(grow))
                 cat(paste0(" ", length(grow)," families\n" ))  
                 for(id in ids) {
                     cat(paste0("family",id," " )) 
                     Ntries <- famqual <- 0              
                     while ( Ntries<30) { 
                         while(famqual<hab.tot.quality){
                              
                              families$qual[id] <- famqual <- sum(as.matrix(hab, ncol=matNcols , nrow=matNrows, byrow=FALSE)[ter==id][as.matrix(hab, ncol=matNcols , nrow=matNrows, byrow=FALSE)[ter==id]>1], na.rm=T) # only count suitable hab
 
                              current <- which(ter==id)
                              adj0 <- adj1 <- adj2 <-   NULL
                                                
                              adj0 <- adjacent(rter, current, directions=8, pairs=FALSE)
                              adj2 <-  adj0[which(ter[adj0]==0 & as.matrix(hab, ncol=matNcols , nrow=matNrows, byrow=FALSE)[adj0]==2)] #exclude occupied territory and null/dispersal habitat
                              adj1 <-  adj0[which(ter[adj0]==0 & as.matrix(hab, ncol=matNcols , nrow=matNrows, byrow=FALSE)[adj0]==1)] #exclude occupied territory and null/suitable habitat
                                       
                             if(length(adj2)>0 & Ntries<30) { 
                                       adj1 <- NULL
                                       Ntries<- Ntries+1
                                       cat("-") 
                                       #print("adj2")
                                       best <-  adj2[sample(length(adj2),1)] #randomly pick one of the best adjacent pixels
                                       ter[best] <- id
                                  
                                   
                                          families$qual[id] <- famqual <- sum(as.matrix(hab, ncol=matNcols , nrow=matNrows, byrow=FALSE)[ter==id][as.matrix(hab, ncol=matNcols , nrow=matNrows, byrow=FALSE)[ter==id]>1], na.rm=TRUE) # only count suitable hab
                                          patches <- NULL
                                          xy <- xyFromCell(rter, which(ter==id & as.matrix(hab, ncol=matNcols , nrow=matNrows, byrow=FALSE)==2)  )
                                          patches <- st_cast(  st_as_sf ( st_buffer(st_sfc(  st_multipoint(x = matrix(xy, ncol=2))) ,75)), "POLYGON"  )
                                     
                                          if(nrow(patches)>1) { 
                                                   #print("split territories")           ## several territories split = keep going
                                                   larger_patch_cells <-  unique(cellFromXY(rter,data.frame(st_coordinates(patches[which(st_area(patches)==max(st_area(patches))),])[,c(1,2)]) ))
                                                   larger_patch_cells <- larger_patch_cells[larger_patch_cells+1 %in% which(ter==id)] #### +1?????
                                                            if(length(larger_patch_cells)>7)  { 
                                                                  Ntries <- 31
                                                                  ter[ter==id] <- 99     
                                                                  famqual <- 99                     ## keep tried terr unoccupiable for that round?
                                                                  ter[larger_patch_cells] <- id
                                                                  families$qual[id] <-  sum(as.matrix(hab, ncol=matNcols , nrow=matNrows, byrow=FALSE)[ter==id][as.matrix(hab, ncol=matNcols , nrow=matNrows, byrow=FALSE)[ter==id]>1], na.rm=TRUE) # only count suitable hab
                                                             } else { 
                                                                   families$qual[id] <- famqual <- length(larger_patch_cells)*2
                                                                    }
                                                }
                                            
                                        
                                          if(families$qual[id] > hab.tot.quality & nrow(patches)==1) { ## one territory not split = win
                                                               Ntries <- 31
                                                               famqual <- 99
                                                               #print("settled")
                                                               grow <- grow[grow!=id]              }
                              } 
                                 
                            
                           if(length(adj2)==0 & length(adj1)>0 & Ntries<30) {
                                     Ntries<- Ntries+1
                                     famqual <- 0
                                     secbest <- adj1[sample(length(adj1),1)]
                                     ter[secbest] <- id           # id territory for next try but it is disp not suit so dont count in famdf
                            }
                                      
                            if(length(adj1)==0 & length(adj2)==0 |  length(adj1)>0 & Ntries>29 ) {
                                                   #print("no option")
                                                   Ntries <- 31
                                                   famqual <- 99
                                                       #   if(length(adj)==0) {
                                                                grow <- grow[grow!=id]
                                                              #  families$qual[id] <- sum(as.matrix(hab, ncol=matNcols , nrow=matNrows, byrow=FALSE)[ter==id])
                                                                ter[ ter==id ] <- 0 # free territory
                             } 
                        #print(paste0("try #",Ntries) )
                                 } # while
                           } #if N<30next try
                          cat("|")
                     #  else { next }
                            #print("next")
                  } #id
       
                          cat("\n")
         } #if(length(grow)>0) 
         
          
        ## omit starting points within dispersal from territories and moves into dispersal previsouy recorded
        ter[startcells$cell[startid_suboptimal] ] <- 0 
        ter[ter==99] <- 0
        ter[ as.matrix(hab, ncol=matNcols , nrow=matNrows, byrow=FALSE)<2] <- 0
        
          
        families$num.m[which(families$qual < floor(hab.tot.quality/2))] <- 0
        families$num.f[which(families$qual < floor(hab.tot.quality/2))] <- 0
        families$young[which(families$qual < floor(hab.tot.quality/2))] <- 0
        # sapply(families$fam.id, release.territory, fam=families, ter=ter)
         
        not_settling <- length(families$fam.id[which(families$num.m+families$num.f==0)])
        cat(paste0("not_settling: ",not_settling,"  -  ")) # is it foolproof here ?
   
         
            
        values(rter) <- c(matrix(c(ter), ncol=matNcols , nrow=matNrows, byrow=FALSE))
          
          
         rter_sf <-  rter
         rter_sf[rter==0] <- NA # faster to omit all empty cells..
         
         ### foolproof if none settle
     if (length(which(!is.na(values(rter)))) >0){
              fm <- st_as_sf(as.polygons( rter_sf , dissolve = T))  #  TRUE, takes longerbut useful  
              print("fm")
              print(fm)
              fm <- fm[fm$layer>0,]
              if(nrow(fm)>0){
                  names(fm)[1] <- "family"
                  fm$layer <- "starting territories"
                }
               famgrid <- fm
      }
           
         startpop <- famgrid
         
        Nfam_settled <- nrow(families[which(families$num.f+families$num.m>1),])
        Nfam_youngs <- length(which(families$young==1) )
        Nfam_2youngs<- length(which(families$young==2) )
         
         print( families)
        Nads <- sum(families$num.f,families$num.m)
        Nyoungs<- sum(families$young) 
         

return_list_start  <- list( families,rter )
  
 ("simulation over  -  ") 
return(return_list_start)
} 
